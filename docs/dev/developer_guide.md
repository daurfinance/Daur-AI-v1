# Руководство разработчика Daur-AI

## Обзор архитектуры

Daur-AI — это универсальный автономный ИИ-агент, способный управлять компьютером через текстовые команды. Архитектура проекта построена по модульному принципу для обеспечения легкой расширяемости и кроссплатформенности.

### Основные компоненты:

1. **Ядро агента** (`agent/core.py`): Координирует работу всех компонентов и обрабатывает команды пользователя.
2. **AI-компоненты** (`ai/`): Отвечают за интерпретацию команд пользователя с помощью локальных моделей ИИ.
3. **Платформенные модули** (`platforms/`): Реализуют взаимодействие с системой для конкретных платформ (Windows, macOS).
4. **Интерфейсы** (`ui/`): Предоставляют пользовательский интерфейс (консольный или графический).

## Структура проекта

```
src/
  ├── main.py                    # Точка входа в приложение
  ├── agent/
  │   └── core.py                # Ядро агента
  ├── ai/
  │   ├── model_manager.py       # Управление ИИ-моделями
  │   └── trainer.py             # Обучение моделей на логах
  ├── apps/
  │   └── manager.py             # Управление приложениями
  ├── config/
  │   └── settings.py            # Модуль настроек
  ├── files/
  │   └── manager.py             # Операции с файлами
  ├── input/
  │   └── controller.py          # Управление вводом
  ├── logger/
  │   ├── logger.py              # Логирование
  │   └── exporter.py            # Экспорт логов
  ├── parser/
  │   └── command_parser.py      # Парсинг команд
  ├── platforms/                 # Платформенно-зависимый код
  │   ├── common/
  │   ├── windows/
  │   └── macos/
  └── ui/
      ├── console.py             # Консольный интерфейс
      └── gui.py                 # Графический интерфейс
```

## Рабочий процесс агента

1. Пользователь вводит команду через UI (консоль или GUI)
2. Команда передается в ядро агента (`DaurAgent`)
3. Ядро передает команду парсеру (`CommandParser`)
4. Парсер анализирует команду:
   - Для простых команд - использует регулярные выражения
   - Для сложных команд - использует локальную ИИ-модель
5. Парсер возвращает структурированный список действий
6. Ядро последовательно выполняет действия через соответствующие контроллеры
7. Результаты выполнения логируются и отображаются пользователю

## Кроссплатформенность

Проект обеспечивает кроссплатформенность через систему абстракций и платформенно-зависимых реализаций:

- `platforms/common/` содержит общие интерфейсы
- `platforms/windows/` и `platforms/macos/` содержат специфичные реализации

## Работа с AI-моделями

### Поддерживаемые форматы моделей:

- GGUF/GGML (через llama.cpp)
- PyTorch (через Hugging Face Transformers)

### Инициализация модели:

```python
from src.ai.model_manager import AIModelManager

# Создание менеджера модели
ai_manager = AIModelManager(
    model_path="/path/to/model.gguf",
    use_gpu=True,
    context_length=4096
)

# Ленивая загрузка (происходит при первой генерации)
response = ai_manager.generate_text("Привет, мир!")
```

### Обучение модели:

```python
from src.ai.trainer import AITrainer

# Создание тренера
trainer = AITrainer(
    model_path="/path/to/base/model",
    output_dir="/path/to/output"
)

# Дообучение на логах
trainer.finetune_model(
    log_path="/path/to/logs",
    epochs=3
)
```

## Разработка новых функций

### Добавление новой команды:

1. Добавьте новый паттерн в `CommandParser._command_patterns`
2. Реализуйте обработчик нового действия в соответствующем контроллере
3. Добавьте документацию для команды

### Добавление поддержки новой платформы:

1. Создайте новую директорию в `platforms/`
2. Реализуйте `input.py` и `apps.py` с интерфейсом, совместимым с общим
3. Добавьте определение платформы в `agent/core.py`

## Работа с тестами

### Запуск тестов:

```bash
python -m unittest discover -s tests
```

### Добавление новых тестов:

1. Создайте новый файл в директории `tests/`
2. Наследуйтесь от `BaseTestCase` из `tests/base.py`
3. Реализуйте необходимые тестовые методы

## Сборка приложения

### Для Windows:
```bash
cd build/windows
python build.py
```

### Для macOS:
```bash
cd build/macos
python setup.py py2app
```

## Отладка и логирование

Проект использует стандартную библиотеку `logging` с настраиваемыми уровнями:

```python
import logging
logger = logging.getLogger('daur_ai')
logger.debug("Отладочное сообщение")
logger.info("Информационное сообщение")
logger.warning("Предупреждение")
logger.error("Ошибка")
```

Логи записываются в файлы в директории, указанной в конфигурации, а также выводятся в консоль при запуске с флагом `--debug`.

## Рекомендации по стилю кода

- Следуйте PEP 8
- Используйте аннотации типов
- Документируйте классы и методы в формате docstring
- Пишите комментарии к сложным участкам кода
- Обрабатывайте исключения и логируйте их

## Примеры расширений

### Пример добавления нового типа действия:

```python
# В command_parser.py добавляем паттерн
self._command_patterns['new_action'] = r'выполни новое действие (\w+)'

# В соответствующем контроллере добавляем обработчик
def execute_new_action(self, action):
    target = action['params']['target']
    # Логика для выполнения действия
    return result
```

### Пример добавления поддержки новой модели:

```python
# В model_manager.py добавляем новый тип
def _detect_model_type(self):
    # Существующий код...
    elif ext == '.new_format':
        self.model_type = "new_model_type"
        self.logger.info("Обнаружена модель нового формата")
    
# В model_manager.py добавляем поддержку загрузки
def load_model(self):
    # Существующий код...
    elif self.model_type == "new_model_type":
        try:
            from new_model_lib import NewModel
            self.model = NewModel.from_path(self.model_path)
            self.is_loaded = True
            return True
        except Exception as e:
            self.logger.error(f"Ошибка загрузки: {e}")
            return False
```

## Контроль версий

Проект использует семантическое версионирование (SemVer):

- MAJOR: изменения API, несовместимые с предыдущими версиями
- MINOR: новый функционал с сохранением обратной совместимости
- PATCH: исправления ошибок с сохранением обратной совместимости
