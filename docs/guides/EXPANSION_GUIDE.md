# Daur-AI v2.0: –ü–æ–ª–Ω–æ–µ –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –†–∞—Å—à–∏—Ä–µ–Ω–∏—é –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏

**–î–∞—Ç–∞:** 25 –æ–∫—Ç—è–±—Ä—è 2025  
**–í–µ—Ä—Å–∏—è:** 2.0  
**–ê–≤—Ç–æ—Ä:** Manus AI

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

1. [–û–±–∑–æ—Ä –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è](#–æ–±–∑–æ—Ä-–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è)
2. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-—Å–∏—Å—Ç–µ–º—ã)
3. [–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Input Module](#—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ-input-module)
4. [–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Hardware Module](#—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ-hardware-module)
5. [–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Vision Module](#—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ-vision-module)
6. [–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–æ–¥—É–ª–µ–π](#—Å–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤—ã—Ö-–º–æ–¥—É–ª–µ–π)
7. [API –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è](#api-–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)
8. [–ü—Ä–∏–º–µ—Ä—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π](#–ø—Ä–∏–º–µ—Ä—ã-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π)

---

## üéØ –û–±–∑–æ—Ä –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –†–∞—Å—à–∏—Ä–µ–Ω–∏—è

–°–∏—Å—Ç–µ–º–∞ Daur-AI v2.0 —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–∞ —Å —É—á–µ—Ç–æ–º –º–æ–¥—É–ª—å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏. –í–æ—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è:

### 1. **–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–æ–¥—É–ª–µ–π**
- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –≤ Input, Hardware, Vision –º–æ–¥—É–ª–∏
- –£–ª—É—á—à–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π
- –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### 2. **–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–æ–¥—É–ª–µ–π**
- –ú–æ–¥—É–ª–∏ –¥–ª—è —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–æ–≤—ã—Ö —Ç–∏–ø–æ–≤ —É—Å—Ç—Ä–æ–π—Å—Ç–≤

### 3. **REST API –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è**
- –°–æ–∑–¥–∞–Ω–∏–µ API endpoints
- WebSocket –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º–∏

### 4. **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏**
- OpenAI API
- Google Vision API
- Telegram Bot API
- Stripe API

### 5. **–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ AI –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π**
- –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
- –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏–π
- –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Å–ª–æ–∂–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

---

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –°–∏—Å—Ç–µ–º—ã

### –¢–µ–∫—É—â–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:

```
Daur-AI v2.0
‚îú‚îÄ‚îÄ Input Module (–º—ã—à–∫–∞, –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞)
‚îú‚îÄ‚îÄ Hardware Module (–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ, –¥—Ä–∞–π–≤–µ—Ä—ã)
‚îú‚îÄ‚îÄ Vision Module (—ç–∫—Ä–∞–Ω, —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ)
‚îú‚îÄ‚îÄ Device Manager (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è)
‚îú‚îÄ‚îÄ Presentations Module (–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏)
‚îú‚îÄ‚îÄ Media Module (–≤–∏–¥–µ–æ, —Ñ–æ—Ç–æ)
‚îú‚îÄ‚îÄ Graphics Module (Blender, Unity)
‚îú‚îÄ‚îÄ Documents Module (–¥–æ–∫—É–º–µ–Ω—Ç—ã)
‚îú‚îÄ‚îÄ Browser Module (–±—Ä–∞—É–∑–µ—Ä)
‚îú‚îÄ‚îÄ Android Module (Android)
‚îú‚îÄ‚îÄ Client Module (–∫–ª–∏–µ–Ω—Ç)
‚îú‚îÄ‚îÄ Programming Module (–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ)
‚îú‚îÄ‚îÄ Logic Module (–ª–æ–≥–∏–∫–∞)
‚îú‚îÄ‚îÄ Planning Module (–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ)
‚îî‚îÄ‚îÄ Monitoring Module (–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥)
```

### –ü—Ä–∏–Ω—Ü–∏–ø—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:

1. **–ú–æ–¥—É–ª—å–Ω–æ—Å—Ç—å** - –ö–∞–∂–¥—ã–π –º–æ–¥—É–ª—å –Ω–µ–∑–∞–≤–∏—Å–∏–º
2. **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è** - –ú–æ–¥—É–ª–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –≤–º–µ—Å—Ç–µ —á–µ—Ä–µ–∑ Device Manager
3. **–†–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å** - –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
4. **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å** - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
5. **–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å** - –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

---

## üñ±Ô∏è –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Input Module

### –°–ø–æ—Å–æ–± 1: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –º—ã—à–∏

**–§–∞–π–ª:** `src/input/mouse_controller.py`

```python
# –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥ –≤ –∫–ª–∞—Å—Å MouseController

def mouse_pattern(self, pattern: str, duration: float = 1.0) -> bool:
    """
    –ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω –º—ã—à–∫–æ–π
    
    Args:
        pattern: –ü–∞—Ç—Ç–µ—Ä–Ω ('circle', 'square', 'triangle')
        duration: –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏—è
        
    Returns:
        bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏
    """
    try:
        import math
        current_pos = self.get_position()
        center_x, center_y = current_pos.x, current_pos.y
        
        if pattern == 'circle':
            # –†–∏—Å—É–µ–º –∫—Ä—É–≥
            radius = 100
            steps = 36
            for i in range(steps + 1):
                angle = (i / steps) * 2 * math.pi
                x = center_x + int(radius * math.cos(angle))
                y = center_y + int(radius * math.sin(angle))
                self.move_to(x, y, duration=duration/steps)
        
        elif pattern == 'square':
            # –†–∏—Å—É–µ–º –∫–≤–∞–¥—Ä–∞—Ç
            size = 100
            points = [
                (center_x - size, center_y - size),
                (center_x + size, center_y - size),
                (center_x + size, center_y + size),
                (center_x - size, center_y + size),
                (center_x - size, center_y - size)
            ]
            for x, y in points:
                self.move_to(x, y, duration=duration/len(points))
        
        self.logger.info(f"–ü–∞—Ç—Ç–µ—Ä–Ω –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω: {pattern}")
        return True
    
    except Exception as e:
        self.logger.error(f"–û—à–∏–±–∫–∞ —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ø–∞—Ç—Ç–µ—Ä–Ω–∞: {e}")
        return False


def mouse_find_and_click(self, image_path: str) -> bool:
    """
    –ù–∞–π—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞ —ç–∫—Ä–∞–Ω–µ –∏ –Ω–∞–∂–∞—Ç—å –Ω–∞ –Ω–µ–≥–æ
    
    Args:
        image_path: –ü—É—Ç—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
        
    Returns:
        bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏
    """
    try:
        import pyautogui
        from PIL import Image
        
        # –ù–∞–π—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        location = pyautogui.locateOnScreen(image_path, confidence=0.8)
        
        if location:
            # –ù–∞–∂–∞—Ç—å –≤ —Ü–µ–Ω—Ç—Ä –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            center_x = location[0] + location[2] // 2
            center_y = location[1] + location[3] // 2
            self.move_to(center_x, center_y, duration=0.3)
            self.click()
            return True
        
        return False
    
    except Exception as e:
        self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∏ –∫–ª–∏–∫–∞: {e}")
        return False
```

### –°–ø–æ—Å–æ–± 2: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å–µ–Ω—Å–æ—Ä–Ω–æ–≥–æ –≤–≤–æ–¥–∞

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/input/touch_controller.py

from dataclasses import dataclass
from typing import List, Tuple
import logging

@dataclass
class TouchPoint:
    """–¢–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è"""
    x: int
    y: int
    pressure: float = 1.0
    timestamp: float = 0.0


class TouchController:
    """–ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Å–µ–Ω—Å–æ—Ä–Ω–æ–≥–æ –≤–≤–æ–¥–∞"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        self.logger = logging.getLogger('daur_ai.touch_controller')
    
    def tap(self, x: int, y: int, duration: float = 0.1) -> bool:
        """–û–¥–∏–Ω–æ—á–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ"""
        try:
            # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è —Å–µ–Ω—Å–æ—Ä–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
            self.logger.info(f"Tap at ({x}, {y})")
            return True
        except Exception as e:
            self.logger.error(f"Touch error: {e}")
            return False
    
    def long_press(self, x: int, y: int, duration: float = 1.0) -> bool:
        """–î–ª–∏—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–∂–∞—Ç–∏–µ"""
        try:
            self.logger.info(f"Long press at ({x}, {y}) for {duration}s")
            return True
        except Exception as e:
            self.logger.error(f"Long press error: {e}")
            return False
    
    def swipe(self, start_x: int, start_y: int, end_x: int, end_y: int,
             duration: float = 0.5) -> bool:
        """–°–≤–∞–π–ø"""
        try:
            self.logger.info(f"Swipe from ({start_x}, {start_y}) to ({end_x}, {end_y})")
            return True
        except Exception as e:
            self.logger.error(f"Swipe error: {e}")
            return False
    
    def pinch(self, center_x: int, center_y: int, scale: float = 0.5,
             duration: float = 0.5) -> bool:
        """–ñ–µ—Å—Ç pinch (—Å–∂–∞—Ç–∏–µ)"""
        try:
            self.logger.info(f"Pinch at ({center_x}, {center_y}) with scale {scale}")
            return True
        except Exception as e:
            self.logger.error(f"Pinch error: {e}")
            return False
    
    def rotate(self, center_x: int, center_y: int, angle: float = 45,
              duration: float = 0.5) -> bool:
        """–ñ–µ—Å—Ç –ø–æ–≤–æ—Ä–æ—Ç–∞"""
        try:
            self.logger.info(f"Rotate at ({center_x}, {center_y}) by {angle} degrees")
            return True
        except Exception as e:
            self.logger.error(f"Rotate error: {e}")
            return False
```

---

## üîß –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Hardware Module

### –°–ø–æ—Å–æ–± 1: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ GPU

```python
# –î–æ–±–∞–≤–∏—Ç—å –≤ src/hardware/driver_manager.py

def get_gpu_info(self) -> Dict[str, Any]:
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ GPU
    
    Returns:
        Dict: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ GPU
    """
    try:
        import subprocess
        
        gpu_info = {
            'devices': [],
            'total_memory': 0,
            'used_memory': 0,
            'temperature': 0
        }
        
        # –î–ª—è NVIDIA GPU
        try:
            result = subprocess.run(
                ['nvidia-smi', '--query-gpu=index,name,memory.total,memory.used,temperature.gpu',
                 '--format=csv,noheader,nounits'],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split(',')
                    gpu_info['devices'].append({
                        'index': int(parts[0].strip()),
                        'name': parts[1].strip(),
                        'total_memory': int(parts[2].strip()),
                        'used_memory': int(parts[3].strip()),
                        'temperature': float(parts[4].strip())
                    })
        
        except Exception as e:
            self.logger.warning(f"NVIDIA GPU info not available: {e}")
        
        return gpu_info
    
    except Exception as e:
        self.logger.error(f"Error getting GPU info: {e}")
        return {}


def get_battery_info(self) -> Dict[str, Any]:
    """
    –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–∞—Ç–∞—Ä–µ–µ
    
    Returns:
        Dict: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–∞—Ç–∞—Ä–µ–µ
    """
    try:
        battery = psutil.sensors_battery()
        
        if battery:
            return {
                'percent': battery.percent,
                'seconds_left': battery.secsleft,
                'power_plugged': battery.power_plugged
            }
        
        return {}
    
    except Exception as e:
        self.logger.error(f"Error getting battery info: {e}")
        return {}
```

### –°–ø–æ—Å–æ–± 2: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/hardware/temperature_monitor.py

import logging
from typing import Dict, Any, List

class TemperatureMonitor:
    """–ú–æ–Ω–∏—Ç–æ—Ä —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        self.logger = logging.getLogger('daur_ai.temperature_monitor')
    
    def get_cpu_temperature(self) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É CPU"""
        try:
            import psutil
            temps = psutil.sensors_temperatures()
            
            if 'coretemp' in temps:
                return temps['coretemp'][0].current
            elif 'k10temp' in temps:
                return temps['k10temp'][0].current
            
            return 0.0
        
        except Exception as e:
            self.logger.error(f"Error getting CPU temperature: {e}")
            return 0.0
    
    def get_all_temperatures(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã"""
        try:
            import psutil
            temps = psutil.sensors_temperatures()
            
            result = {}
            for name, entries in temps.items():
                result[name] = [
                    {
                        'label': entry.label,
                        'current': entry.current,
                        'high': entry.high,
                        'critical': entry.critical
                    }
                    for entry in entries
                ]
            
            return result
        
        except Exception as e:
            self.logger.error(f"Error getting temperatures: {e}")
            return {}
    
    def check_temperature_health(self) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã"""
        temps = self.get_all_temperatures()
        
        health = {
            'status': 'healthy',
            'warnings': [],
            'critical': []
        }
        
        for component, entries in temps.items():
            for entry in entries:
                if entry['critical'] and entry['current'] > entry['critical']:
                    health['status'] = 'critical'
                    health['critical'].append(f"{component}: {entry['current']}¬∞C")
                elif entry['high'] and entry['current'] > entry['high']:
                    health['status'] = 'warning'
                    health['warnings'].append(f"{component}: {entry['current']}¬∞C")
        
        return health
```

---

## üëÅÔ∏è –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Vision Module

### –°–ø–æ—Å–æ–± 1: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –ª–∏—Ü

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/vision/face_recognition.py

import logging
from typing import List, Dict, Any, Optional, Tuple
from PIL import Image
import numpy as np

class FaceRecognizer:
    """–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ª–∏—Ü"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        self.logger = logging.getLogger('daur_ai.face_recognizer')
        try:
            import face_recognition
            self.face_recognition = face_recognition
        except ImportError:
            self.logger.warning("face_recognition library not installed")
            self.face_recognition = None
    
    def detect_faces(self, image: Image.Image) -> List[Dict[str, Any]]:
        """
        –û–±–Ω–∞—Ä—É–∂–∏—Ç—å –ª–∏—Ü–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
        
        Args:
            image: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            
        Returns:
            List: –°–ø–∏—Å–æ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –ª–∏—Ü
        """
        if not self.face_recognition:
            return []
        
        try:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ numpy array
            image_array = np.array(image)
            
            # –û–±–Ω–∞—Ä—É–∂–∏—Ç—å –ª–∏—Ü–∞
            face_locations = self.face_recognition.face_locations(image_array)
            face_encodings = self.face_recognition.face_encodings(image_array, face_locations)
            
            faces = []
            for (top, right, bottom, left), encoding in zip(face_locations, face_encodings):
                faces.append({
                    'location': (left, top, right - left, bottom - top),
                    'encoding': encoding,
                    'confidence': 0.95
                })
            
            self.logger.info(f"Detected {len(faces)} faces")
            return faces
        
        except Exception as e:
            self.logger.error(f"Error detecting faces: {e}")
            return []
    
    def recognize_face(self, face_encoding: np.ndarray,
                      known_encodings: List[np.ndarray],
                      tolerance: float = 0.6) -> Tuple[bool, float]:
        """
        –†–∞—Å–ø–æ–∑–Ω–∞—Ç—å –ª–∏—Ü–æ
        
        Args:
            face_encoding: –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–∏—Ü–∞
            known_encodings: –ò–∑–≤–µ—Å—Ç–Ω—ã–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
            tolerance: –î–æ–ø—É—Å–∫
            
        Returns:
            Tuple: (—É–∑–Ω–∞–Ω–æ –ª–∏, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å)
        """
        if not self.face_recognition or not known_encodings:
            return False, 0.0
        
        try:
            distances = self.face_recognition.face_distance(known_encodings, face_encoding)
            
            if len(distances) == 0:
                return False, 0.0
            
            min_distance = np.min(distances)
            is_match = min_distance < tolerance
            confidence = 1.0 - min_distance
            
            return is_match, confidence
        
        except Exception as e:
            self.logger.error(f"Error recognizing face: {e}")
            return False, 0.0
```

### –°–ø–æ—Å–æ–± 2: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è QR –∫–æ–¥–æ–≤

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/vision/qr_code_reader.py

import logging
from typing import List, Dict, Any, Optional
from PIL import Image

class QRCodeReader:
    """–ß—Ç–µ–Ω–∏–µ QR –∫–æ–¥–æ–≤"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        self.logger = logging.getLogger('daur_ai.qr_code_reader')
        try:
            import pyzbar.pyzbar as pyzbar
            self.pyzbar = pyzbar
        except ImportError:
            self.logger.warning("pyzbar library not installed")
            self.pyzbar = None
    
    def detect_qr_codes(self, image: Image.Image) -> List[Dict[str, Any]]:
        """
        –û–±–Ω–∞—Ä—É–∂–∏—Ç—å QR –∫–æ–¥—ã –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
        
        Args:
            image: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            
        Returns:
            List: –°–ø–∏—Å–æ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö QR –∫–æ–¥–æ–≤
        """
        if not self.pyzbar:
            return []
        
        try:
            qr_codes = self.pyzbar.decode(image)
            
            results = []
            for qr in qr_codes:
                results.append({
                    'type': qr.type,
                    'data': qr.data.decode('utf-8'),
                    'location': {
                        'x': qr.rect.left,
                        'y': qr.rect.top,
                        'width': qr.rect.width,
                        'height': qr.rect.height
                    }
                })
            
            self.logger.info(f"Detected {len(results)} QR codes")
            return results
        
        except Exception as e:
            self.logger.error(f"Error detecting QR codes: {e}")
            return []
    
    def read_qr_code(self, image: Image.Image) -> Optional[str]:
        """
        –ü—Ä–æ—á–∏—Ç–∞—Ç—å –ø–µ—Ä–≤—ã–π QR –∫–æ–¥
        
        Args:
            image: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            
        Returns:
            Optional[str]: –î–∞–Ω–Ω—ã–µ QR –∫–æ–¥–∞
        """
        qr_codes = self.detect_qr_codes(image)
        
        if qr_codes:
            return qr_codes[0]['data']
        
        return None
```

---

## üÜï –°–æ–∑–¥–∞–Ω–∏–µ –ù–æ–≤—ã—Ö –ú–æ–¥—É–ª–µ–π

### –®–∞–±–ª–æ–Ω –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –º–æ–¥—É–ª—è

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/new_module/new_module.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Daur-AI: –ù–æ–≤—ã–π –º–æ–¥—É–ª—å
–û–ø–∏—Å–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏

–í–µ—Ä—Å–∏—è: 2.0
–î–∞—Ç–∞: 25.10.2025
–ê–≤—Ç–æ—Ä: Manus AI
"""

import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime


@dataclass
class NewModuleConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è"""
    enabled: bool = True
    timeout: float = 30.0
    retry_count: int = 3
    created_at: datetime = field(default_factory=datetime.now)


class NewModule:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –º–æ–¥—É–ª—è"""
    
    def __init__(self, config: Optional[NewModuleConfig] = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        
        Args:
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è
        """
        self.logger = logging.getLogger('daur_ai.new_module')
        self.config = config or NewModuleConfig()
        self.logger.info("New Module –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def do_something(self) -> bool:
        """
        –í—ã–ø–æ–ª–Ω–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ
        
        Returns:
            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏
        """
        try:
            self.logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è...")
            # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è
            return True
        
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞: {e}")
            return False
    
    def get_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –º–æ–¥—É–ª—è"""
        return {
            'enabled': self.config.enabled,
            'timeout': self.config.timeout,
            'created_at': self.config.created_at.isoformat()
        }


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
_new_module = None


def get_new_module(config: Optional[NewModuleConfig] = None) -> NewModule:
    """–ü–æ–ª—É—á–∏—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä –º–æ–¥—É–ª—è"""
    global _new_module
    if _new_module is None:
        _new_module = NewModule(config)
    return _new_module
```

### –§–∞–π–ª –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–¥—É–ª—è

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/new_module/__init__.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Daur-AI: –ù–æ–≤—ã–π –º–æ–¥—É–ª—å
"""

from .new_module import (
    NewModuleConfig,
    NewModule,
    get_new_module
)

__all__ = [
    'NewModuleConfig',
    'NewModule',
    'get_new_module'
]
```

---

## üîó API –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

### –°–ø–æ—Å–æ–± 1: REST API endpoints

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/web/device_api.py

from flask import Flask, jsonify, request
from src.devices import get_device_manager

app = Flask(__name__)
manager = get_device_manager()

# ===== Mouse endpoints =====

@app.route('/api/mouse/move', methods=['POST'])
def mouse_move():
    """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –º—ã—à—å"""
    data = request.json
    x = data.get('x', 0)
    y = data.get('y', 0)
    duration = data.get('duration', 0.5)
    
    success = manager.mouse_move(x, y, duration)
    
    return jsonify({
        'success': success,
        'message': 'Mouse moved' if success else 'Failed to move mouse'
    })


@app.route('/api/mouse/click', methods=['POST'])
def mouse_click():
    """–ù–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É –º—ã—à–∏"""
    data = request.json
    x = data.get('x')
    y = data.get('y')
    button = data.get('button', 'left')
    
    success = manager.mouse_click(x, y, button)
    
    return jsonify({
        'success': success,
        'message': 'Mouse clicked' if success else 'Failed to click'
    })


# ===== Keyboard endpoints =====

@app.route('/api/keyboard/type', methods=['POST'])
def keyboard_type():
    """–ù–∞–ø–µ—á–∞—Ç–∞—Ç—å —Ç–µ–∫—Å—Ç"""
    data = request.json
    text = data.get('text', '')
    
    success = manager.keyboard_type(text)
    
    return jsonify({
        'success': success,
        'message': 'Text typed' if success else 'Failed to type'
    })


@app.route('/api/keyboard/hotkey', methods=['POST'])
def keyboard_hotkey():
    """–ö–æ–º–±–∏–Ω–∞—Ü–∏—è –∫–ª–∞–≤–∏—à"""
    data = request.json
    keys = data.get('keys', [])
    
    success = manager.keyboard_hotkey(*keys)
    
    return jsonify({
        'success': success,
        'message': 'Hotkey executed' if success else 'Failed to execute'
    })


# ===== Screen endpoints =====

@app.route('/api/screen/analyze', methods=['GET'])
def screen_analyze():
    """–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —ç–∫—Ä–∞–Ω"""
    analysis = manager.screen_analyze()
    
    return jsonify({
        'success': True,
        'data': analysis
    })


@app.route('/api/screen/find', methods=['POST'])
def screen_find():
    """–ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –Ω–∞ —ç–∫—Ä–∞–Ω–µ"""
    data = request.json
    text = data.get('text', '')
    
    obj = manager.screen_find_object(text)
    
    return jsonify({
        'success': obj is not None,
        'data': obj
    })


# ===== Hardware endpoints =====

@app.route('/api/hardware/info', methods=['GET'])
def hardware_info():
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–∏"""
    info = manager.hardware_get_info()
    
    return jsonify({
        'success': True,
        'data': info
    })


@app.route('/api/hardware/health', methods=['GET'])
def hardware_health():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è"""
    health = manager.hardware_check_health()
    
    return jsonify({
        'success': True,
        'data': health
    })


# ===== Status endpoints =====

@app.route('/api/status', methods=['GET'])
def get_status():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã"""
    status = manager.get_full_status()
    
    return jsonify({
        'success': True,
        'data': status
    })


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
```

### –°–ø–æ—Å–æ–± 2: WebSocket –ø–æ–¥–¥–µ—Ä–∂–∫–∞

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/web/device_websocket.py

from flask import Flask
from flask_socketio import SocketIO, emit, on
from src.devices import get_device_manager
import json

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*")
manager = get_device_manager()

@socketio.on('connect')
def handle_connect():
    """–ö–ª–∏–µ–Ω—Ç –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è"""
    emit('response', {'data': 'Connected to Daur-AI'})


@socketio.on('mouse_move')
def handle_mouse_move(data):
    """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –º—ã—à—å"""
    x = data.get('x', 0)
    y = data.get('y', 0)
    duration = data.get('duration', 0.5)
    
    success = manager.mouse_move(x, y, duration)
    
    emit('response', {
        'event': 'mouse_move',
        'success': success
    }, broadcast=True)


@socketio.on('keyboard_type')
def handle_keyboard_type(data):
    """–ù–∞–ø–µ—á–∞—Ç–∞—Ç—å —Ç–µ–∫—Å—Ç"""
    text = data.get('text', '')
    
    success = manager.keyboard_type(text)
    
    emit('response', {
        'event': 'keyboard_type',
        'success': success
    }, broadcast=True)


@socketio.on('screen_analyze')
def handle_screen_analyze():
    """–ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —ç–∫—Ä–∞–Ω"""
    analysis = manager.screen_analyze()
    
    emit('response', {
        'event': 'screen_analyze',
        'data': analysis
    }, broadcast=True)


@socketio.on('get_status')
def handle_get_status():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å"""
    status = manager.get_full_status()
    
    emit('response', {
        'event': 'get_status',
        'data': status
    }, broadcast=True)


if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5001, debug=True)
```

---

## ü§ñ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å AI

### –î–æ–±–∞–≤–ª–µ–Ω–∏–µ OpenAI –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/ai/openai_integration.py

import logging
from typing import Optional, Dict, Any
import openai

class OpenAIIntegration:
    """–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å OpenAI API"""
    
    def __init__(self, api_key: str):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        
        Args:
            api_key: API –∫–ª—é—á OpenAI
        """
        self.logger = logging.getLogger('daur_ai.openai_integration')
        openai.api_key = api_key
    
    def analyze_screenshot(self, image_path: str) -> Optional[str]:
        """
        –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç —Å –ø–æ–º–æ—â—å—é GPT-4 Vision
        
        Args:
            image_path: –ü—É—Ç—å –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
            
        Returns:
            Optional[str]: –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        """
        try:
            with open(image_path, 'rb') as f:
                image_data = f.read()
            
            response = openai.ChatCompletion.create(
                model="gpt-4-vision-preview",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{image_data}"
                                }
                            },
                            {
                                "type": "text",
                                "text": "Describe what you see in this screenshot"
                            }
                        ]
                    }
                ]
            )
            
            return response.choices[0].message.content
        
        except Exception as e:
            self.logger.error(f"Error analyzing screenshot: {e}")
            return None
    
    def get_next_action(self, current_state: str) -> Optional[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        
        Args:
            current_state: –û–ø–∏—Å–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            
        Returns:
            Optional[str]: –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ
        """
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an AI assistant that helps automate computer tasks."
                    },
                    {
                        "role": "user",
                        "content": f"Current state: {current_state}\n\nWhat should be the next action?"
                    }
                ]
            )
            
            return response.choices[0].message.content
        
        except Exception as e:
            self.logger.error(f"Error getting next action: {e}")
            return None
```

---

## üí° –ü—Ä–∏–º–µ—Ä—ã –†–∞—Å—à–∏—Ä–µ–Ω–∏–π

### –ü—Ä–∏–º–µ—Ä 1: –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/automation/form_filler.py

from src.devices import get_device_manager
from src.vision import get_screen_analyzer
import time

class FormFiller:
    """–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ–æ—Ä–º"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        self.manager = get_device_manager()
        self.analyzer = get_screen_analyzer()
    
    def fill_form(self, form_data: dict) -> bool:
        """
        –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Ñ–æ—Ä–º—É
        
        Args:
            form_data: –î–∞–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã {field_label: value}
            
        Returns:
            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏
        """
        try:
            for field_label, value in form_data.items():
                # –ù–∞–π—Ç–∏ –ø–æ–ª–µ
                field = self.analyzer.find_object_by_text(field_label)
                
                if not field:
                    continue
                
                # –ù–∞–∂–∞—Ç—å –Ω–∞ –ø–æ–ª–µ
                self.manager.mouse_click(field['center'][0], field['center'][1])
                time.sleep(0.3)
                
                # –û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ
                self.manager.keyboard_hotkey('ctrl', 'a')
                time.sleep(0.1)
                
                # –í–≤–µ—Å—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏–µ
                self.manager.keyboard_type(str(value))
                time.sleep(0.2)
            
            return True
        
        except Exception as e:
            print(f"Error filling form: {e}")
            return False
```

### –ü—Ä–∏–º–µ—Ä 2: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∏—Å—Ç–µ–º—ã —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/monitoring/system_monitor.py

from src.devices import get_device_manager
import time
import threading

class SystemMonitor:
    """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∏—Å—Ç–µ–º—ã —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏"""
    
    def __init__(self, check_interval: float = 60.0):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        
        Args:
            check_interval: –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        """
        self.manager = get_device_manager()
        self.check_interval = check_interval
        self.is_running = False
    
    def start_monitoring(self):
        """–ù–∞—á–∞—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"""
        self.is_running = True
        thread = threading.Thread(target=self._monitor_loop)
        thread.daemon = True
        thread.start()
    
    def stop_monitoring(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"""
        self.is_running = False
    
    def _monitor_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–∏
                hw_info = self.manager.hardware_get_info()
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ
                health = self.manager.hardware_check_health()
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ—Ä–æ–≥–∏
                if hw_info['cpu_percent'] > 80:
                    self._notify(f"High CPU usage: {hw_info['cpu_percent']}%")
                
                if hw_info['ram_percent'] > 85:
                    self._notify(f"High RAM usage: {hw_info['ram_percent']}%")
                
                if hw_info['disk_percent'] > 90:
                    self._notify(f"Low disk space: {hw_info['disk_percent']}% used")
                
                if health['overall_status'] != 'healthy':
                    self._notify(f"System health: {health['overall_status']}")
                
                time.sleep(self.check_interval)
            
            except Exception as e:
                print(f"Monitoring error: {e}")
                time.sleep(self.check_interval)
    
    def _notify(self, message: str):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"""
        print(f"[ALERT] {message}")
        # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –≤ Telegram, Email –∏ —Ç.–¥.
```

### –ü—Ä–∏–º–µ—Ä 3: –ó–∞–ø–∏—Å—å –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

```python
# –ù–æ–≤—ã–π —Ñ–∞–π–ª: src/automation/scenario_recorder.py

from src.input import get_mouse_controller, get_keyboard_controller
from src.devices import get_device_manager
import json
import time
from typing import List, Dict, Any

class ScenarioRecorder:
    """–ó–∞–ø–∏—Å—å –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        self.mouse = get_mouse_controller()
        self.keyboard = get_keyboard_controller()
        self.manager = get_device_manager()
        self.recording = False
        self.events: List[Dict[str, Any]] = []
    
    def start_recording(self):
        """–ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å"""
        self.recording = True
        self.events = []
        
        # –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å callbacks
        self.mouse.register_event_callback('move', self._on_mouse_move)
        self.mouse.register_event_callback('click', self._on_mouse_click)
        self.keyboard.register_event_callback('press', self._on_key_press)
    
    def stop_recording(self) -> List[Dict[str, Any]]:
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å"""
        self.recording = False
        return self.events
    
    def save_scenario(self, filepath: str):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π"""
        with open(filepath, 'w') as f:
            json.dump(self.events, f, indent=2, default=str)
    
    def load_scenario(self, filepath: str) -> List[Dict[str, Any]]:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ü–µ–Ω–∞—Ä–∏–π"""
        with open(filepath, 'r') as f:
            self.events = json.load(f)
        return self.events
    
    def playback_scenario(self, speed: float = 1.0):
        """–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ —Å—Ü–µ–Ω–∞—Ä–∏–π"""
        for i, event in enumerate(self.events):
            if i > 0:
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–±—ã—Ç–∏—è–º–∏
                delay = (event['timestamp'] - self.events[i-1]['timestamp']) / speed
                time.sleep(delay)
            
            event_type = event['type']
            
            if event_type == 'mouse_move':
                self.manager.mouse_move(event['x'], event['y'], duration=0.1)
            
            elif event_type == 'mouse_click':
                self.manager.mouse_click(event['x'], event['y'], event['button'])
            
            elif event_type == 'key_press':
                self.manager.keyboard_press(event['key'])
            
            elif event_type == 'type':
                self.manager.keyboard_type(event['text'])
    
    def _on_mouse_move(self, event):
        """Callback –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏"""
        if self.recording:
            self.events.append({
                'type': 'mouse_move',
                'x': event.position.x,
                'y': event.position.y,
                'timestamp': event.timestamp.timestamp()
            })
    
    def _on_mouse_click(self, event):
        """Callback –¥–ª—è –∫–ª–∏–∫–∞ –º—ã—à–∏"""
        if self.recording:
            self.events.append({
                'type': 'mouse_click',
                'x': event.position.x,
                'y': event.position.y,
                'button': event.button.value if event.button else 'left',
                'timestamp': event.timestamp.timestamp()
            })
    
    def _on_key_press(self, event):
        """Callback –¥–ª—è –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏"""
        if self.recording:
            self.events.append({
                'type': 'key_press',
                'key': event.key,
                'timestamp': event.timestamp.timestamp()
            })
```

---

## üìö –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –†–∞—Å—à–∏—Ä–µ–Ω–∏—é

### 1. **–ü–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏**
- –ò–∑—É—á–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É
- –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ, –Ω—É–∂–µ–Ω –ª–∏ –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å –∏–ª–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ
- –°–ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ API –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
- –°–æ–∑–¥–∞–π—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é

### 2. **–í–æ –≤—Ä–µ–º—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏**
- –°–ª–µ–¥—É–π—Ç–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è–º –æ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞
- –î–æ–±–∞–≤–ª—è–π—Ç–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
- –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
- –ü–∏—à–∏—Ç–µ docstrings –¥–ª—è –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π

### 3. **–ü–æ—Å–ª–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏**
- –¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
- –î–æ–±–∞–≤–ª—è–π—Ç–µ unit —Ç–µ—Å—Ç—ã
- –û–±–Ω–æ–≤–ª—è–π—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
- –°–æ–∑–¥–∞–≤–∞–π—Ç–µ –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

### 4. **–õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏**
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–∏–ø–∏–∑–∞—Ü–∏—é (type hints)
- –°–ª–µ–¥—É–π—Ç–µ PEP 8
- –ò–∑–±–µ–≥–∞–π—Ç–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ dependency injection
- –õ–æ–≥–∏—Ä—É–π—Ç–µ –≤—Å–µ –≤–∞–∂–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è

---

## üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –†–∞—Å—à–∏—Ä–µ–Ω–∏–π

### –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
1. REST API endpoints
2. WebSocket –ø–æ–¥–¥–µ—Ä–∂–∫–∞
3. –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ª–∏—Ü
4. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ GPU
5. –ó–∞–ø–∏—Å—å —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

### –°—Ä–µ–¥–Ω–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
1. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å OpenAI
2. QR –∫–æ–¥ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã
4. –°–µ–Ω—Å–æ—Ä–Ω—ã–π –≤–≤–æ–¥
5. –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ñ–æ—Ä–º

### –ù–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
1. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –º—ã—à–∏
2. –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã
3. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏

---

**–°–æ–∑–¥–∞–Ω–æ:** Manus AI  
**–î–∞—Ç–∞:** 25 –æ–∫—Ç—è–±—Ä—è 2025  
**–í–µ—Ä—Å–∏—è:** 2.0

